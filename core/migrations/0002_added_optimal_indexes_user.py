# Generated by Django 5.2.6 on 2025-10-02 04:11

from django.db import migrations, models
from django.db import connection


class Migration(migrations.Migration):
    """
    NOTE: This migration uses a custom implementation of `RunPython` to create and drop indexes concurrently.
    The motivation was to avoid the blocking of the database during the migration in production
    Also we had to remove the default RunSQL because for some reason, django was wrapping that in a transaction
    (even with the `atomic = False` flag)
    leading to errors
    django.db.utils.InternalError: DROP INDEX CONCURRENTLY cannot run inside a transaction block
    inspired by https://hakibenita.com/django-foreign-keys
    """

    atomic = False

    dependencies = [
        ("auth", "0012_alter_user_first_name_max_length"),
        ("core", "0001_initial_creation_of_db"),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AlterField(
                    model_name="user",
                    name="email",
                    field=models.EmailField(max_length=254, unique=True),
                ),
                migrations.AlterField(
                    model_name="user",
                    name="oidc_subject",
                    field=models.CharField(default="", max_length=255),
                ),
                migrations.AddIndex(
                    model_name="user",
                    index=models.Index(
                        fields=["oidc_subject", "email"], name="oidc_subject_email_idx"
                    ),
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    code=lambda apps, schema_editor: _create_indexes_concurrently(
                        schema_editor
                    ),
                    reverse_code=lambda apps,
                    schema_editor: _reverse_indexes_concurrently(schema_editor),
                ),
            ],
        )
    ]


def _create_indexes_concurrently(schema_editor):
    statements = [
        "DROP INDEX CONCURRENTLY IF EXISTS core_user_oidc_subject_7633a38e",
        "DROP INDEX CONCURRENTLY IF EXISTS core_user_oidc_subject_7633a38e_like",
        "CREATE INDEX CONCURRENTLY oidc_subject_email_idx ON core_user (oidc_subject, email)",
    ]
    _execute_concurrently(schema_editor, statements)


def _reverse_indexes_concurrently(schema_editor):
    statements = [
        "DROP INDEX IF EXISTS oidc_subject_email_idx",
        "CREATE INDEX CONCURRENTLY core_user_oidc_subject_7633a38e ON core_user (oidc_subject)",
        "CREATE INDEX CONCURRENTLY core_user_oidc_subject_7633a38e_like ON core_user (oidc_subject varchar_pattern_ops)",
    ]
    _execute_concurrently(schema_editor, statements)


def _execute_concurrently(schema_editor, statements):
    conn = schema_editor.connection if schema_editor else connection
    old_autocommit = conn.get_autocommit()
    try:
        if not old_autocommit:
            conn.set_autocommit(True)
        with conn.cursor() as cursor:
            for sql in statements:
                cursor.execute(sql)
    finally:
        if not old_autocommit:
            conn.set_autocommit(False)
